
<!DOCTYPE html> 
<html> 
<head> 
<meta charset=utf-8> 
<title>Flag - construção de geometria</title> 
<style> 
  body { margin: 0; } 
  canvas { width: 100%; height: 100% } 
</style> 
</head> 
<body> 
<script src="js/three.js"></script> 
<script src="js/OrbitControls.js"></script> 
<script> 

  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  var renderer = new THREE.WebGLRenderer({antialias: true}); 
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.setClearColor(0x220000);
  document.body.appendChild( renderer.domElement );



/*---------------------------------------------------------------------------------*/

  var geo= new THREE.Geometry();


  function point_pos(x,y)
  {
    return 5*x+y
  }


  for (i=0; i<5; i++)
    for (j=0; j<5; j++)
    {

      geo.vertices.push( new THREE.Vector3(i,j,Math.log(0.1+(i*i+j*j)/10)))
    
      geo.colors.push( new THREE.Color(0xff0000) )
    }


  for (i=0; i<4; i++)
    for (j=0; j<4; j++)
    {
      face=new THREE.Face3(point_pos(i,j), point_pos(i,j+1),point_pos(i+1,j))
      face.color=new THREE.Color(0xffff00);
      geo.faces.push( face )

      
      face=new THREE.Face3(point_pos(i+1,j+1), point_pos(i+1,j), point_pos(i,j+1))
      geo.faces.push( face )
    }

  //geo.computeFaceNormals()
  geo.computeVertexNormals()

  var mesh = new THREE.Mesh( geo, 
  new THREE.MeshBasicMaterial({
     vertexColors: THREE.VertexColors,
   flatShading: true,
     side: THREE.DoubleSide,
   //color:0x00f5f5,
   }) 
 )
  var a = mesh.clone()
  a.rotation.z = Math.PI/2
  
  var b = mesh.clone()
  b.rotation.z = 3*Math.PI/2
  
  var c = mesh.clone()
  c.rotation.z = Math.PI
  
  var fanGroup = new THREE.Group()
  fanGroup.add(a)
  fanGroup.add(b)
  fanGroup.add(c)
  fanGroup.add(mesh)



  var finalGroup = new THREE.Group()


  for (i=0; i<5; i++)
    for (j=0; j<5; j++){
      actual = fanGroup.clone()
      actual.position.x = i*8
      actual.position.y = j*8
      finalGroup.add(actual)
}


  scene.add(finalGroup)



  var axesHelper = new THREE.AxesHelper( 5 );
  scene.add( axesHelper );

  var light =  new THREE.PointLight( 0xffffff, 1.0 );
  //light.position={ x: 2, y:1, z: 3};
  light.position.set(4,4,2);


  scene.add(light)
  camera.position.x = 40;
  camera.position.z = 50;
  camera.position.y = -30;
  camera.up = new THREE.Vector3(0,0,1);
  camera.lookAt(new THREE.Vector3(0, 0, 0));

  var controls = new THREE.OrbitControls( camera );


 var t=0;
  function animate() { 
    requestAnimationFrame( animate ); 
    controls.update()
    //camera.lookAt(new THREE.Vector3(0, 0, 0))
    renderer.render( scene, camera ); 
    t=t+0.01;
    for (i = 0; i < 5; i++)
      for (j = 0; j < 5; j++) {
        geo.vertices[point_pos(i,j)].set(i, j, Math.log(0.1+(i*i+j*j)/10)*Math.sin(t))
      }
    geo.dynamic = true
    geo.verticesNeedUpdate = true

    
  } 
  animate();


</script> 
</body> 
</html>